---
title: 'Indoor Positioning Systems: An Exploration Using K-Nearest Neighbors'
author: "Sandesh Ojha, Gautam Kapila, Sachin Chavan, Tazeb Abera"
date: "1/12/2021"
output: html_document
---


```{r results='hide', message=FALSE, echo=FALSE}

setwd("C:/Users/tazeb/OneDrive - Southern Methodist University/7th Semester/QTW/Group_Work/caseStudy")

# Read in the raw "offline" text file
txt = readLines("data/offline.final.trace.txt")
# count lines for comment
sum(substr(txt, 1, 1) == "#")
# total num of lines
length(txt)
```

Processing the raw data
```{r}
# create a function to repeat the operation for each row in the input file
processLine =
  function(x)
    {
    tokens = strsplit(x, "[;=,]")[[1]]
    if (length(tokens) == 10)
      return(NULL)
    tmp = matrix(tokens[-(1:10)], ncol = 4, byrow = TRUE)
    cbind(matrix(tokens[c(2, 4, 6:8, 10)], nrow = nrow(tmp), ncol = 6, byrow = TRUE), tmp)
  }

```



```{r import_libs, include=FALSE, echo=TRUE, cache=TRUE}
#install.packages("dplyr")

#install.packages("tidyr")
#install.packages("dplyr")
#install.packages("fields") 
#install.packages("lattice")
#install.packages("knitr")
#install.packages("ggplot2")
library(tidyr, warn.conflicts = FALSE)
library(dplyr)
library(fields)
library(lattice)
library(knitr)
library(ggplot2)
```

```{r make,  include= FALSE, echo=TRUE, cache=TRUE} 

# get offline, online and onlineSummary along with key functions
source('src/MakeFile.R')
```

##  Methods
The raw data is split into a training dataset and a test dataset. The training dataset contains 15,392 unique lines
After excluding extraneous access points, normalizing orientation values, and translating time variables, a data for analysis is created. 
below is the code and the result

```{r offline_sample, include=TRUE, echo=TRUE, cache=TRUE, fig.cap=cap, warning=FALSE}

subMacs = names(sort(table(offline$mac), decreasing = TRUE))[1:7]
kable(offline[1:5,], caption="Table 1: Formatted Dataset for Analysis", row.names = FALSE)
cap <- "Table 1: Transformed Offline Dataset Structure"

```



Key exploratory data analysis results help to form assumptions and methods for an indoor positioning system using a *k*-nearest neighbors model. Non-normal, multi-modal signal distributions are found when considering signal strength and the angle of the mobile at each (x,y) location reading. This indicates angle has an effect on signal strength. Figure 2 displays this analysis finding for one access point at a single (x,y) position.



```{r angle_density_plot, include=TRUE, echo=TRUE, cache=TRUE, fig.cap=cap}
densityplot( ~ signal | factor(angle), 
             data = offline,
             subset = posX == 24 & posY == 4 & 
                         mac == "00:0f:a3:39:e1:c0",
             bw = 0.5, plot.points = FALSE)
cap <- "Figure 1: Angle Based Density Plots for 00:0f:a3:39:e1:c0"
```

The transformed data set is subsequently aggregated by (x,y) position, angle, and MAC address. Additional analysis using the aggregated data set shows higher variability for stronger signal strengths. Also, the relationship between signal and distance shows that signal strength weakens as distance increases. This negative relationship is expected and can be seen for each access point in Figure 2.

```{r summary_creation, include=FALSE, echo=TRUE, cache=TRUE}
# create table of summary stats by Location, Angle and AP
offline$posXY = paste(offline$posX, offline$posY, sep = "-") # concat x,y

byLocAngleAP = with(offline, 
                    by(offline, list(posXY, angle, mac), 
                       function(x) x))

# calculate summary statistics, reduce down to single summary line
signalSummary = 
  lapply(byLocAngleAP,            
         function(oneLoc) {
           ans = oneLoc[1, ]
           ans$medSignal = median(oneLoc$signal)
           ans$avgSignal = mean(oneLoc$signal)
           ans$num = length(oneLoc$signal)
           ans$sdSignal = sd(oneLoc$signal)
           ans$iqrSignal = IQR(oneLoc$signal)
           ans
           })

# bind all the summary lines together
offlineSummary = do.call("rbind", signalSummary)

```

```{r xyplot, include=TRUE, echo=TRUE, cache=TRUE, fig.cap=cap}

# exclude mac at position 2: "00:0f:a3:39:dd:cd" per author's guidance
offlineSummary_orig = subset(offlineSummary, mac != subMacs[2])

# create a mtrix with relevant positions for six access points on floor plan
AP = matrix(c( 7.5, 6.3, 2.5, -.8, 12.8, -2.8,  
                1, 14, 33.5, 9.3, 33.5, 2.8),
            ncol = 2, byrow = TRUE,
            dimnames = list(subMacs[-2], c("x", "y") ))

# relationship between signal stregnth and distance from AP
# distances from locations of the device emitting vs access point receiving
diffs = offlineSummary_orig[ , c("posX", "posY")] - AP[ offlineSummary_orig$mac, ] 

offlineSummary_orig$dist = sqrt(diffs[ , 1]^2 + diffs[ , 2]^2)

# simplified
xyplot(signal ~ dist | factor(substr(mac,10,117)) , 
       data = offlineSummary_orig,
       xlab ="distance"
       )

cap <- "Figure 2: Relationship Between Signal and Distance"
```

To prepare the training and test data sets for use in a *k*-nearest neighbors model, we aggregate records based on (x,y) position. Signal strengths from each access point for each position are mean-aggregated, forming a data set where each record is unique based on (x,y) position. Each position is associated with a vector of six signal strength values. A sample of this format can be seen in Table 2.

```{r knn_training_example, include=TRUE, echo=TRUE, cache=TRUE, fig.cap=cap}

# this is the original reshape function
reshapeSS = function(data, varSignal = "signal", 
                     keepVars = c("posXY", "posX","posY")) {
  byLocation =
    with(data, by(data, list(posXY), 
                  function(x) {
                    ans = x[1, keepVars]
                    avgSS = tapply(x[ , varSignal ], x$mac, mean)
                    y = matrix(avgSS, nrow = 1, ncol = 6,
                               dimnames = list(ans$posXY,
                                               names(avgSS)))
                    cbind(ans, y)
                  }))

  newDataSS = do.call("rbind", byLocation)
  return(newDataSS)
}

# build all of this into a funciton
trainSS = reshapeSS(offlineSummary_orig, varSignal = "avgSignal")
kable(trainSS[1:5,1:6], caption="Table 2: Formatted Dataset for KNN Use", row.names = FALSE)
cap <- "Table 2: Aggregate Data for Analysis"
```



```{r surface_compare, include=TRUE, echo=TRUE, cache=TRUE, fig.cap=cap}

compareMacList <- c("00:0f:a3:39:dd:cd", "00:0f:a3:39:e1:c0")

surfaceSS = function(data, mac, angle = 45) {
  require(fields)
  oneAPAngle = data[ data$mac == mac & data$angle == angle, ]
  smoothSS = Tps(oneAPAngle[, c("posX","posY")], 
                 oneAPAngle$avgSignal)
  vizSmooth = predictSurface(smoothSS)
  plot.surface(vizSmooth, type = "C", 
               xlab = mac, ylab = "", xaxt = "n", yaxt = "n")
  points(oneAPAngle$posX, oneAPAngle$posY, pch=19, cex = 0.5) 
}

parCur = par(mfrow = c(2,2), mar = rep(1, 4)) 

mapply(surfaceSS, 
       mac = compareMacList[rep(c(1,2), each=2)], 
       angle = rep(c(90, 135), 2), 
       data = list(data = offlineSummary))

par(parCur)
cap <- "Figure 3: Signal Strength for Two Similar Access Points"
```


```{r define_funcs, include=TRUE, echo=TRUE, cache=TRUE}
# define critical prediction and CV functions for analysis purposes

# reshape signal strength, ensure we use if (sampleAngle) for CV purposes
reshapeSS = function(data, varSignal = "signal", 
                     keepVars = c("posXY", "posX","posY"),
                     sampleAngle = FALSE, 
                     refs = seq(0, 315, by = 45)) {
  byLocation =
    with(data, by(data, list(posXY), 
                  function(x) {
                    if (sampleAngle) {
                      x = x[x$angle == sample(refs, size = 1), ]}
                    ans = x[1, keepVars]
                    avgSS = tapply(x[ , varSignal ], x$mac, mean)
                    y = matrix(avgSS, nrow = 1, ncol = 6,
                               dimnames = list(ans$posXY,
                                               names(avgSS)))
                    cbind(ans, y)
                  }))

  newDataSS = do.call("rbind", byLocation)
  return(newDataSS)
}

# get training data for each new obs (including angle logic)

selectTrain = function(angleNewObs, signals = NULL, m = 1){
  refs = seq(0, by = 45, length  = 8)
  nearestAngle = roundOrientation(angleNewObs)
  
  if (m %% 2 == 1) 
    angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)
  else {
    m = m + 1
    angles = seq(-45 * (m - 1) /2, 45 * (m - 1) /2, length = m)
    if (sign(angleNewObs - nearestAngle) > -1) 
      angles = angles[ -1 ]
    else 
      angles = angles[ -m ]
  }
  angles = angles + nearestAngle
  angles[angles < 0] = angles[ angles < 0 ] + 360
  angles[angles > 360] = angles[ angles > 360 ] - 360
  angles = sort(angles) 
  
  offlineSubset = signals[ signals$angle %in% angles, ]
  reshapeSS(offlineSubset, varSignal = "avgSignal")
}

# KNN: FIND NEIGHBORS - AVG BASED
findNN = function(newSignal, trainSubset) {
  diffs = apply(trainSubset[ , 4:9], 1, 
                function(x) x - newSignal) # this inverts, places x,y on cols when called as.numeric
  dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) ) # this gets our distance (euclidean)
  closest = order(dists) # orders our distances in ascending
  return(trainSubset[closest, 1:3 ]) # returns the subset from training with closest distances, gives xy ID, x, y
}


# PREDXY: takes an input of newSignals, their angles, and returns the estimated positions
predXY = function(newSignals, newAngles, trainData, 
                  numAngles = 1, k = 3){
  
  closeXY = list(length = nrow(newSignals))
  
  for (i in 1:nrow(newSignals)) {
    trainSS = selectTrain(newAngles[i], trainData, m = numAngles)
    closeXY[[i]] = findNN(newSignal = as.numeric(newSignals[i, ]),
                           trainSS)
  }

  estXY = lapply(closeXY, function(x)
                            sapply(x[ , 2:3], 
                                    function(x) mean(x[1:k])))
  estXY = do.call("rbind", estXY)
  return(estXY)
}

# ERROR CALCULATION
calcError = 
function(estXY, actualXY) 
   sum( rowSums( (estXY - actualXY)^2) )


# WKNN: WEIGHTED K NEIGHBORS
findWtdNN = function(newSignal, trainSubset) {
  diffs = apply(trainSubset[ , 4:9], 1, 
                function(x) x - newSignal) 
  dists = apply(diffs, 2, function(x) sqrt(sum(x^2)) ) 
  closest = order(dists) # orders distances ascending
  closeXY = trainSubset[closest, 1:3 ]
  weight = as.numeric(1/dists[closest]) 
  return(cbind(closeXY, weight)) 
}

# pull cross validation process into a repeatable function
cross_validate = function(train_full, train_summary, K=20, folds=11, 
                          keepVars = c("posXY", "posX","posY", "orientation", "angle"),
                          wtd=FALSE) {
set.seed(25)
permuteLocs = sample(unique(train_summary$posXY))
permuteLocs = matrix(permuteLocs, ncol = folds, 
                     nrow = floor(length(permuteLocs)/folds))

onlineCVSummary = reshapeSS(train_full, keepVars = keepVars, sampleAngle = TRUE)

err = rep(0, K)

for (j in 1:folds) {
  onlineFold = subset(onlineCVSummary, 
                      posXY %in% permuteLocs[ , j])
  offlineFold = subset(train_summary,
                       posXY %in% permuteLocs[ , -j])
  actualFold = onlineFold[ , c("posX", "posY")]
  
    for (k in 1:K) {
      if(wtd == TRUE){
                       estFold = predXYwtd(newSignals = onlineFold[ , 6:11],
                                 newAngles = onlineFold[ , 4], 
                                 offlineFold, numAngles = 3, k = k)
                       err[k] = err[k] + calcError(estFold, actualFold)
      
                     } else {
                       estFold = predXY(newSignals = onlineFold[ , 6:11],
                                        newAngles = onlineFold[ , 4], 
                                        offlineFold, numAngles = 3, k = k)
                       err[k] = err[k] + calcError(estFold, actualFold)
                     }
                    }
                   }

rmseMin = min(err)
kMin = which(err == rmseMin)[1]

return(list(rmseMin, kMin, err))
}


```

```{r cross_validation_orig, include=FALSE, echo=TRUE, cache=TRUE, warning=FALSE}

# identify dataset for training (exclude MAC per authors guidance)
# get minimum error and optimal K

offline_orig = offline[ offline$mac != "00:0f:a3:39:dd:cd", ]
results = cross_validate(offline_orig, offlineSummary_orig, K=20, wtd=FALSE)
print(paste('results of original',results))

```


``` {r cross_validation_new, include=FALSE, echo=TRUE, cache=TRUE, warning=FALSE}

offline_new = offline[ offline$mac != "00:0f:a3:39:e1:c0", ]
offlineSummary_new = offlineSummary[offlineSummary$mac != "00:0f:a3:39:e1:c0", ]

results_new = cross_validate(offline_new, offlineSummary_new, K=20, wtd=FALSE)
print(paste('results of new',results_new))
```


``` {r cross_validation_combined, include=FALSE, echo=TRUE, cache=TRUE, warning=FALSE}

# modify author's reshapeSS static function to include both MACs
# change this back to 6 cols for KNN investigation

reshapeSS = function(data, varSignal = "signal", 
                     keepVars = c("posXY", "posX","posY"),
                     sampleAngle = FALSE, 
                     refs = seq(0, 315, by = 45)) {
  byLocation =
    with(data, by(data, list(posXY), 
                  function(x) {
                    if (sampleAngle) {
                      x = x[x$angle == sample(refs, size = 1), ]}
                    ans = x[1, keepVars]
                    avgSS = tapply(x[ , varSignal ], x$mac, mean)
                    y = matrix(avgSS, nrow = 1, ncol = 7,
                               dimnames = list(ans$posXY,
                                               names(avgSS)))
                    cbind(ans, y)
                  }))

  newDataSS = do.call("rbind", byLocation)
  return(newDataSS)
}

results_combined = cross_validate(offline, offlineSummary, K=20, wtd=FALSE)
print(paste('results of combined',results_combined))
```



```{r eda_signalstr, include=TRUE, echo=TRUE, cache=TRUE, fig.cap=cap}
# INVESTIGATING SIGNAL STRENGTH
bwplot(signal ~ factor(angle) | mac, 
       data = offline, 
       subset = posX == 2 & posY == 12 
                & mac != "00:0f:a3:39:dd:cd", 
       layout = c(2,3))
cap <- "Figure 4: Angle Influence on Signal Strength for (x,y) Position (2,12)"

```



```{r weighted_vec_ex, include=TRUE, echo=TRUE, cache=TRUE}

# re-establish standard reshapeSS
reshapeSS = function(data, varSignal = "signal", 
                     keepVars = c("posXY", "posX","posY"),
                     sampleAngle = FALSE, 
                     refs = seq(0, 315, by = 45)) {
  byLocation =
    with(data, by(data, list(posXY), 
                  function(x) {
                    if (sampleAngle) {
                      x = x[x$angle == sample(refs, size = 1), ]}
                    ans = x[1, keepVars]
                    avgSS = tapply(x[ , varSignal ], x$mac, mean)
                    y = matrix(avgSS, nrow = 1, ncol = 6,
                               dimnames = list(ans$posXY,
                                               names(avgSS)))
                    cbind(ans, y)
                  }))

  newDataSS = do.call("rbind", byLocation)
  return(newDataSS)
}

# weighted prediction vector results, adjusted
predXYwtd = function(newSignals, newAngles, trainData, 
                     numAngles = 1, k = 3){
  
  closeXY = list(length = nrow(newSignals))
  
  for (i in 1:nrow(newSignals)) {
    trainSS = selectTrain(newAngles[i], trainData, m = numAngles)
    base = findWtdNN(newSignal = as.numeric(newSignals[i, ]), trainSS) # get matrix of x,y, numerator for weights
    wts = append(base[1:k, 4]/sum(base[1:k, 4]), rep(0, nrow(base)-k))  # calculate weights based on K, append zero array for delta of len-k
  }
  return(cbind(base[,2:3], wts))
}

onlineSummary_orig = onlineSummary[, !(names(onlineSummary) %in% "00:0f:a3:39:dd:cd")]
weight_ex <- predXYwtd(onlineSummary_orig[1,6:11], onlineSummary[,4], offlineSummary_orig, numAngles = 3, k=3)
kable(weight_ex[1:5,], caption="Table 3: Weight Vectors for k=3", row.names = FALSE)
```

```{r wtd_nn, include=FALSE, echo=TRUE, cache=TRUE}

# weighted prediction function in total
predXYwtd = function(newSignals, newAngles, trainData, 
                     numAngles = 1, k = 3){
  
  closeXY = list(length = nrow(newSignals))
  
  for (i in 1:nrow(newSignals)) {
    trainSS = selectTrain(newAngles[i], trainData, m = numAngles)
    base = findWtdNN(newSignal = as.numeric(newSignals[i, ]), trainSS) # get matrix of x,y, numerator for weights
    wts = append(base[1:k, 4]/sum(base[1:k, 4]), rep(0, nrow(base)-k))  # calculate weights based on K, append zero array for delta of len-k
    base[, 2:3] = base[, 2:3]*wts # multiply weights array * matrix of x,y to get weighted vals
    closeXY[[i]] = base[,1:3] # append weighted xy, x, y values to list
  }
  estXY = lapply(closeXY, # loop over each xy position-based dataframe
                 function(x) sapply(x[ , 2:3], function(x) sum(x))) # sum all as neighbors > k == 0 now, and x,y is already weighted!
  estXY = do.call("rbind", estXY) # pull predictions together for each observation xy in test set
  return(estXY)
}

```


```{r wtd_investigation, include=FALSE, echo=FALSE, cache=TRUE, warning=FALSE}
results_wtd_orig = cross_validate(offline_orig, offlineSummary_orig, K=20, wtd=TRUE)
print(paste('results of weighted', results_wtd_orig))
```

```{r viz_floor, include=TRUE, cache=TRUE, echo=TRUE, fig.cap=cap}

estXYk6wtd = predXYwtd(newSignals = onlineSummary_orig[ , 6:11], 
                       newAngles = onlineSummary_orig[ , 4], 
                       offlineSummary_orig, numAngles = 3, k = 3)
  
# show errors on the floor
floorErrorMap = function(estXY, actualXY, trainPoints = NULL, AP = NULL){
  
    plot(0, 0, xlim = c(0, 35), ylim = c(-3, 15), type = "n",
         xlab = "", ylab = "", axes = FALSE)
    box()
    if ( !is.null(AP) ) points(AP, pch = 15)
    if ( !is.null(trainPoints) )
    points(trainPoints, pch = 19, col="grey", cex = 0.6)
    
    points(x = actualXY[, 1], y = actualXY[, 2], 
           pch = 19, cex = 0.8 )
    points(x = estXY[, 1], y = estXY[, 2], 
           pch = 8, cex = 0.8 )
    segments(x0 = estXY[, 1], y0 = estXY[, 2],
             x1 = actualXY[, 1], y1 = actualXY[ , 2],
             lwd = 2, col = "red")
}


trainPoints = offlineSummary_orig[ offlineSummary_orig$angle == 0 & 
                                   offlineSummary_orig$mac == "00:0f:a3:39:e1:c0" ,
                                   c("posX", "posY")]

oldPar = par(mar = c(1, 1, 1, 1))

floorErrorMap(estXYk6wtd, onlineSummary_orig[ , c("posX","posY")], 
              trainPoints = trainPoints, AP = AP)

par(oldPar)

cap <- "Figure 5: Floor Level Errors Using Weighted KNN with 6 Neighbors"
```



```{r wtd_investigation_new, include=FALSE, echo=TRUE, cache=TRUE, warning=FALSE}
results_wtd_new = cross_validate(offline_new, offlineSummary_new, K=20, wtd=TRUE)

print(paste('results of weighted', results_wtd_new))
```

Cross-validation of a weighted *k*-nearest neighbors model on the adjusted training data is executed using 11 folds and 15 unique (x,y) positions. The optimal model uses six nearest neighbors and results in a root mean square error of 908.38. This result is better than both the mean-based *k*-nearest neighbors model as well as the weighted model considering the alternate access point.

```{r wtd_combined, include=FALSE, echo=TRUE, cache=TRUE, warning=FALSE}

reshapeSS = function(data, varSignal = "signal", 
                     keepVars = c("posXY", "posX","posY"),
                     sampleAngle = FALSE, 
                     refs = seq(0, 315, by = 45)) {
  byLocation =
    with(data, by(data, list(posXY), 
                  function(x) {
                    if (sampleAngle) {
                      x = x[x$angle == sample(refs, size = 1), ]}
                    ans = x[1, keepVars]
                    avgSS = tapply(x[ , varSignal ], x$mac, mean)
                    y = matrix(avgSS, nrow = 1, ncol = 7,
                               dimnames = list(ans$posXY,
                                               names(avgSS)))
                    cbind(ans, y)
                  }))

  newDataSS = do.call("rbind", byLocation)
  return(newDataSS)
}

results_combined_wtd = cross_validate(offline, offlineSummary, K=20, wtd=TRUE)
print(paste('results of combined',results_combined_wtd))
```



## Results



```{r compare_access_points, include=TRUE, cache=TRUE, echo=TRUE, fig.cap=cap}
ggplot()+
  geom_line(mapping=aes(x=seq(1,20,1), y=results[[3]], color="00:0f:a3:39:e1:c0"), show.legend = TRUE)+
  geom_line(mapping=aes(x=seq(1,20,1), y=results_new[[3]], color="00:0f:a3:39:dd:cd"), linetype="dashed", show.legend = TRUE)+
  geom_line(mapping=aes(x=seq(1,20,1), y=results_combined[[3]], color="Both APs"), linetype="dotdash", show.legend = TRUE)+
  theme(legend.position="top", legend.text = element_text(colour="black", size=8, 
                                                          face="bold"))+
  theme(legend.position="top", 
        legend.text = element_text(colour="black", size=8, face="bold"),
        legend.title=element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black")
        )+
  labs(y="error", x="k")

cap <- "Figure 6: Learning Curves for Each Scenario Given K Neighbors"
```



```{r compare_methods, include=TRUE, cache=TRUE, echo=TRUE, fig.cap=cap}
ggplot(mapping=aes(x=seq(1,20,1)))+
  geom_line(mapping=aes(y=results[[3]], color="red"), linetype="solid")+
  geom_line(mapping=aes(y=results_new[[3]], color="blue"), linetype="solid")+
  geom_line(mapping=aes(y=results_combined[[3]], color="black"), linetype="solid")+
  geom_line(mapping=aes(y=results_wtd_orig[[3]], color="red"), linetype="dashed")+
  geom_line(mapping=aes(y=results_wtd_new[[3]], color="blue"), linetype="dashed")+
  geom_line(mapping=aes(y=results_combined_wtd[[3]], color="black"), linetype="dashed")+
  theme(legend.position="top", 
        legend.text = element_text(colour="black", size=8, face="bold"),
        legend.title=element_blank(),
        panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black")
        )+
  scale_color_discrete(name = "MAC", labels = c("Include 39:e1:c0", "Include 39:dd:cd", "Include Both"))+
  labs(y="error", x="k")

cap <- "Figure 7: Learning Curves for Each Scenario Given K Neighbors"
```



## References

